// generated by pbpg, do not modify

package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

type CalcData struct{}

func main() {
	result, err := ParseCalc(os.Args[1], nil)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(result)
}

// Expression = Term { AddOp Term }
func (p *CalcParser) stateExpression() (int, error) {
	var err error
	var ret int
	var v1 int
	var v2temp string
	var v2 []string
	var v3temp int
	var v3 []int
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateTerm()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2ErrorStack := p.errorStack
			p.errorStack = &parserErrorStack{}
			v2temp, err = p.stateAddOp()
			if p.errorStack.coalesce() != nil {
				v2ErrorStack.merge(p.errorStack)
			}
			p.errorStack = v2ErrorStack
			if err == nil {
				v3ErrorStack := p.errorStack
				p.errorStack = &parserErrorStack{}
				v3temp, err = p.stateTerm()
				if p.errorStack.coalesce() != nil {
					v3ErrorStack.merge(p.errorStack)
				}
				p.errorStack = v3ErrorStack
			}
			if err != nil {
				p = p.backtrack()
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionExpression(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionExpression(pos int, v1 int, v2 []string, v3 []int) int {
	r := v1
	for i, v := range v2 {
		switch v {
		case "+":
			r = r + v3[i]
		case "-":
			r = r - v3[i]
		}
	}

	return r

}

// Term = Factor { MultOp Factor }
func (p *CalcParser) stateTerm() (int, error) {
	var err error
	var ret int
	var v1 int
	var v2temp string
	var v2 []string
	var v3temp int
	var v3 []int
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateFactor()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2ErrorStack := p.errorStack
			p.errorStack = &parserErrorStack{}
			v2temp, err = p.stateMultOp()
			if p.errorStack.coalesce() != nil {
				v2ErrorStack.merge(p.errorStack)
			}
			p.errorStack = v2ErrorStack
			if err == nil {
				v3ErrorStack := p.errorStack
				p.errorStack = &parserErrorStack{}
				v3temp, err = p.stateFactor()
				if p.errorStack.coalesce() != nil {
					v3ErrorStack.merge(p.errorStack)
				}
				p.errorStack = v3ErrorStack
			}
			if err != nil {
				p = p.backtrack()
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionTerm(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionTerm(pos int, v1 int, v2 []string, v3 []int) int {
	r := v1
	for i, v := range v2 {
		switch v {
		case "*":
			r = r * v3[i]
		case "/":
			r = r / v3[i]
		}
	}
	return r

}

// Factor = ( "(" Expression ")" ) | Number
func (p *CalcParser) stateFactor() (int, error) {
	var err error
	var ret int
	var a1Pos int
	var v1 string
	var v2 int
	var v3 string
	var v4 int
	a1Pos = 1
	// group
	p = p.predict()
	v1, err = p.literal("(")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateExpression()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			v3, err = p.literal(")")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
		}
	}
	if err != nil {
		p = p.backtrack()
	} else {
		p = p.accept()
	}
	if err != nil {
		a1Pos = 2
		v4ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v4, err = p.stateNumber()
		if p.errorStack.coalesce() != nil {
			v4ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v4ErrorStack
		if err != nil {
			a1Pos = -1
		}
	}
	if err == nil {
		ret = p.Data.actionFactor(p.pos, a1Pos, v1, v2, v3, v4)
	}

	return ret, err
}

func (p *CalcData) actionFactor(pos int, a1Pos int, v1 string, v2 int, v3 string, v4 int) int {
	var r int
	switch a1Pos {
	case 1:
		r = v2
	case 2:
		r = v4
	}
	return r

}

// AddOp = "+" | "-"
func (p *CalcParser) stateAddOp() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	a1Pos = 1
	v1, err = p.literal("+")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("-")
		if err != nil {
			p.errorStack.error(err, p.pos)
		}
		if err != nil {
			a1Pos = -1
		}
	}
	if err == nil {
		ret = p.Data.actionAddOp(p.pos, a1Pos, v1, v2)
	}

	return ret, err
}

func (p *CalcData) actionAddOp(pos int, a1Pos int, v1 string, v2 string) string {
	var r string
	switch a1Pos {
	case 1:
		r = v1
	case 2:
		r = v2
	}
	return r

}

// MultOp = "*" | "/"
func (p *CalcParser) stateMultOp() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	a1Pos = 1
	v1, err = p.literal("*")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("/")
		if err != nil {
			p.errorStack.error(err, p.pos)
		}
		if err != nil {
			a1Pos = -1
		}
	}
	if err == nil {
		ret = p.Data.actionMultOp(p.pos, a1Pos, v1, v2)
	}

	return ret, err
}

func (p *CalcData) actionMultOp(pos int, a1Pos int, v1 string, v2 string) string {
	var r string
	switch a1Pos {
	case 1:
		r = v1
	case 2:
		r = v2
	}
	return r

}

// Number = [ Neg ] Digit { Digit }
func (p *CalcParser) stateNumber() (int, error) {
	var err error
	var ret int
	var v1 string
	var v2 string
	var v3temp string
	var v3 []string
	// option
	p = p.predict()
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateNeg()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err != nil {
		p = p.backtrack()
		err = nil
	} else {
		p = p.accept()
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateDigit()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			// repetition
			for {
				p = p.predict()
				v3ErrorStack := p.errorStack
				p.errorStack = &parserErrorStack{}
				v3temp, err = p.stateDigit()
				if p.errorStack.coalesce() != nil {
					v3ErrorStack.merge(p.errorStack)
				}
				p.errorStack = v3ErrorStack
				if err != nil {
					p = p.backtrack()
					err = nil
					break
				} else {
					v3 = append(v3, v3temp)
					p = p.accept()
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionNumber(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionNumber(pos int, v1 string, v2 string, v3 []string) int {
	stringNumber := v1 + v2 + strings.Join(v3, "")
	num, _ := strconv.Atoi(stringNumber)
	return num

}

// Neg = "-"
func (p *CalcParser) stateNeg() (string, error) {
	var err error
	var ret string
	var v1 string
	v1, err = p.literal("-")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		ret = p.Data.actionNeg(p.pos, v1)
	}

	return ret, err
}

func (p *CalcData) actionNeg(pos int, v1 string) string {
	return v1
}

// Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
func (p *CalcParser) stateDigit() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	var v3 string
	var v4 string
	var v5 string
	var v6 string
	var v7 string
	var v8 string
	var v9 string
	var v10 string
	a1Pos = 1
	v1, err = p.literal("0")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("1")
		if err != nil {
			p.errorStack.error(err, p.pos)
		}
		if err != nil {
			a1Pos = 3
			v3, err = p.literal("2")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
			if err != nil {
				a1Pos = 4
				v4, err = p.literal("3")
				if err != nil {
					p.errorStack.error(err, p.pos)
				}
				if err != nil {
					a1Pos = 5
					v5, err = p.literal("4")
					if err != nil {
						p.errorStack.error(err, p.pos)
					}
					if err != nil {
						a1Pos = 6
						v6, err = p.literal("5")
						if err != nil {
							p.errorStack.error(err, p.pos)
						}
						if err != nil {
							a1Pos = 7
							v7, err = p.literal("6")
							if err != nil {
								p.errorStack.error(err, p.pos)
							}
							if err != nil {
								a1Pos = 8
								v8, err = p.literal("7")
								if err != nil {
									p.errorStack.error(err, p.pos)
								}
								if err != nil {
									a1Pos = 9
									v9, err = p.literal("8")
									if err != nil {
										p.errorStack.error(err, p.pos)
									}
									if err != nil {
										a1Pos = 10
										v10, err = p.literal("9")
										if err != nil {
											p.errorStack.error(err, p.pos)
										}
										if err != nil {
											a1Pos = -1
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionDigit(p.pos, a1Pos, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10)
	}

	return ret, err
}

func (p *CalcData) actionDigit(pos int, a1Pos int, v1 string, v2 string, v3 string, v4 string, v5 string, v6 string, v7 string, v8 string, v9 string, v10 string) string {
	return fmt.Sprintf("%v", a1Pos-1)
}

func ParseCalc(input string, data *CalcData) (int, error) {
	p := newCalcParser(input, data)

	ret, err := p.stateExpression()
	if err == nil {
		if strings.TrimSpace(p.input[p.pos:]) != "" {
			err = p.errorStack.coalesce()
			return ret, err
		}
	} else {
		err = p.errorStack.coalesce()
	}

	return ret, err
}

type CalcParser struct {
	input       string
	pos         int
	lineOffsets []int
	Data        *CalcData
	errorStack  *parserErrorStack

	predictStack []*CalcParser
}

func newCalcParser(input string, data *CalcData) *CalcParser {
	return &CalcParser{
		input:       input,
		lineOffsets: CalcGenerateLineOffsets(input),
		Data:        data,
		errorStack:  &parserErrorStack{},
	}
}

func CalcGenerateLineOffsets(input string) []int {
	var ret []int

	lines := strings.Split(input, "\n")

	offset := 0
	for _, v := range lines {
		ret = append(ret, len(v)+1+offset)
		offset += len(v) + 1
	}
	return ret
}

func (p *CalcParser) literal(want string) (string, error) {
	var errExpected = fmt.Errorf("expected %v", want)

	count := 0
	for r, s := utf8.DecodeRuneInString(p.input[p.pos+count:]); s > 0 && unicode.IsSpace(r); r, s = utf8.DecodeRuneInString(p.input[p.pos+count:]) {
		count += s
	}

	if strings.HasPrefix(p.input[p.pos+count:], want) {
		p.pos += count + len(want)
		return want, nil
	}

	return "", errExpected
}

func (p *CalcParser) predict() *CalcParser {
	p.predictStack = append(p.predictStack, p)
	return &CalcParser{
		input:        p.input,
		pos:          p.pos,
		lineOffsets:  p.lineOffsets,
		predictStack: p.predictStack,
		errorStack:   p.errorStack,
		Data:         p.Data,
	}
}

func (p *CalcParser) backtrack() *CalcParser {
	pp := p.predictStack[len(p.predictStack)-1]
	pp.predictStack = pp.predictStack[:len(pp.predictStack)-1]
	pp.errorStack = p.errorStack
	return pp
}

func (p *CalcParser) accept() *CalcParser {
	pp := p.backtrack()
	pp.pos = p.pos
	return pp
}

type parserErrorStack struct {
	stack []*parseError
}

type parseError struct {
	err error
	pos int
}

func (e *parserErrorStack) clear() {
	e.stack = []*parseError{}
}

func (e *parserErrorStack) merge(e2 *parserErrorStack) {
	e.stack = append(e.stack, e2.stack...)
}

func (e *parserErrorStack) error(err error, pos int) {
	e.stack = append(e.stack, &parseError{err: err, pos: pos})
}

func (e *parserErrorStack) coalesce() error {
	var bestDepth int
	var es []error

COALESCE_OUTER:
	for _, v := range e.stack {
		if v.pos > bestDepth {
			bestDepth = v.pos
			es = []error{v.err}
		} else if v.pos == bestDepth {
			// deduplicate errors at a given depth
			for _, w := range es {
				if w.Error() == v.err.Error() {
					continue COALESCE_OUTER
				}
			}
			es = append(es, v.err)
		}
	}

	if len(es) == 0 {
		return nil
	} else if len(es) == 1 {
		return es[0]
	} else {
		// print the error stack in reverse order
		var ret string
		for i := len(es) - 1; i >= 0; i-- {
			ret += es[i].Error() + "\n"
		}
		return errors.New(strings.TrimSpace(ret))
	}
}

func (e *parserErrorStack) depth() int {
	var ret int
	for _, v := range e.stack {
		if v.pos > ret {
			ret = v.pos
		}
	}
	return ret
}
