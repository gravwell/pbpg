// generated by pbpg, do not modify

package main

import (
	"errors"
	"fmt"
	"log"
	"strings"
	"unicode"
	"unicode/utf8"
)

//	The top level production is the initial state to attempt to reduce.
//
// Program = { Comment } [ Header ] { Types } Line { Line }
func (p *pbpgParser) stateProgram() error {
	var err error
	// repetition
	for {
		p = p.predict()
		v1ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		err = p.stateComment()
		if p.errorStack.coalesce() != nil {
			v1ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v1ErrorStack
		if err != nil {
			p = p.backtrack()
			err = nil
			break
		} else {
			p = p.accept()
		}
	}
	if err == nil {
		// option
		p = p.predict()
		v1ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		err = p.stateHeader()
		if p.errorStack.coalesce() != nil {
			v1ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v1ErrorStack
		if err != nil {
			p = p.backtrack()
			err = nil
		} else {
			p = p.accept()
		}
		if err == nil {
			// repetition
			for {
				p = p.predict()
				v1ErrorStack := p.errorStack
				p.errorStack = &parserErrorStack{}
				err = p.stateTypes()
				if p.errorStack.coalesce() != nil {
					v1ErrorStack.merge(p.errorStack)
				}
				p.errorStack = v1ErrorStack
				if err != nil {
					p = p.backtrack()
					err = nil
					break
				} else {
					p = p.accept()
				}
			}
			if err == nil {
				v1ErrorStack := p.errorStack
				p.errorStack = &parserErrorStack{}
				err = p.stateLine()
				if p.errorStack.coalesce() != nil {
					v1ErrorStack.merge(p.errorStack)
				}
				p.errorStack = v1ErrorStack
				if err == nil {
					// repetition
					for {
						p = p.predict()
						v1ErrorStack := p.errorStack
						p.errorStack = &parserErrorStack{}
						err = p.stateLine()
						if p.errorStack.coalesce() != nil {
							v1ErrorStack.merge(p.errorStack)
						}
						p.errorStack = v1ErrorStack
						if err != nil {
							p = p.backtrack()
							err = nil
							break
						} else {
							p = p.accept()
						}
					}
				}
			}
		}
	}
	return err
}

// Header = CodeBlock
func (p *pbpgParser) stateHeader() error {
	var err error
	var v1 string
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateCodeBlock()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err == nil {
		p.Data.actionHeader(p.pos, v1)
	}

	return err
}

func (p *pbpgData) actionHeader(pos int, v1 string) {
	p.out.WriteString(doNotModify)
	p.out.WriteString(v1)
}

// Types = "type" Name type
func (p *pbpgParser) stateTypes() error {
	var err error
	var v1 string
	var v2 string
	var v3 string
	v1, err = p.literal("type")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateName()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			{
				n, lexeme, lerr := p.Data.lextype(p.input[p.pos:])
				p.pos += n
				if lerr != nil {
					err = lerr
				} else {
					err = nil
					v3 = lexeme
				}
			}
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
		}
	}
	if err == nil {
		p.Data.actionTypes(p.pos, v1, v2, v3)
	}

	return err
}

func (p *pbpgData) actionTypes(pos int, v1 string, v2 string, v3 string) {
	if _, ok := p.typeMap[v2]; ok {
		log.Fatalf("type %v redeclared", v2)
	}
	p.typeMap[v2] = v3

}

// Line = Comment | Production
func (p *pbpgParser) stateLine() error {
	var err error
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	err = p.stateComment()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err != nil {
		v1ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		err = p.stateProduction()
		if p.errorStack.coalesce() != nil {
			v1ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v1ErrorStack
	}
	return err
}

// Production = Name "=" [ Expression ] "." [ Action ] [ Error ]
func (p *pbpgParser) stateProduction() error {
	var err error
	var v1 string
	var v2 string
	var v3 *Expression
	var v4 string
	var v5 string
	var v6 string
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateName()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err == nil {
		v2, err = p.literal("=")
		if err != nil {
			p.errorStack.error(err, p.pos)
		}
		if err == nil {
			// option
			p = p.predict()
			v3ErrorStack := p.errorStack
			p.errorStack = &parserErrorStack{}
			v3, err = p.stateExpression()
			if p.errorStack.coalesce() != nil {
				v3ErrorStack.merge(p.errorStack)
			}
			p.errorStack = v3ErrorStack
			if err != nil {
				p = p.backtrack()
				err = nil
			} else {
				p = p.accept()
			}
			if err == nil {
				v4, err = p.literal(".")
				if err != nil {
					p.errorStack.error(err, p.pos)
				}
				if err == nil {
					// option
					p = p.predict()
					v5ErrorStack := p.errorStack
					p.errorStack = &parserErrorStack{}
					v5, err = p.stateAction()
					if p.errorStack.coalesce() != nil {
						v5ErrorStack.merge(p.errorStack)
					}
					p.errorStack = v5ErrorStack
					if err != nil {
						p = p.backtrack()
						err = nil
					} else {
						p = p.accept()
					}
					if err == nil {
						// option
						p = p.predict()
						v6ErrorStack := p.errorStack
						p.errorStack = &parserErrorStack{}
						v6, err = p.stateError()
						if p.errorStack.coalesce() != nil {
							v6ErrorStack.merge(p.errorStack)
						}
						p.errorStack = v6ErrorStack
						if err != nil {
							p = p.backtrack()
							err = nil
						} else {
							p = p.accept()
						}
					}
				}
			}
		}
	}
	if err == nil {
		p.Data.actionProduction(p.pos, v1, v2, v3, v4, v5, v6)
	}

	return err
}

func (p *pbpgData) actionProduction(pos int, v1 string, v2 string, v3 *Expression, v4 string, v5 string, v6 string) {
	if p.stateMap[v1] != nil {
		log.Fatalf("%v redeclared", v1)
	}
	p.stateMap[v1] = v3
	p.orderedStates = append(p.orderedStates, v1)

	p.emitState(v1, v3, v5, v6)

	if p.entryPoint == "" {
		p.entryPoint = v1
	}

}

// Action = "Action" CodeBlock
func (p *pbpgParser) stateAction() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	v1, err = p.literal("Action")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateCodeBlock()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
	}
	if err == nil {
		ret = p.Data.actionAction(p.pos, v1, v2)
	}

	return ret, err
}

func (p *pbpgData) actionAction(pos int, v1 string, v2 string) string {
	return v2
}

// Error = "Error" CodeBlock
func (p *pbpgParser) stateError() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	v1, err = p.literal("Error")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateCodeBlock()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
	}
	if err == nil {
		ret = p.Data.actionError(p.pos, v1, v2)
	}

	return ret, err
}

func (p *pbpgData) actionError(pos int, v1 string, v2 string) string {
	return v2
}

// CodeBlock = "{" Code "}"
func (p *pbpgParser) stateCodeBlock() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	var v3 string
	v1, err = p.literal("{")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateCode()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			v3, err = p.literal("}")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
		}
	}
	if err == nil {
		ret = p.Data.actionCodeBlock(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionCodeBlock(pos int, v1 string, v2 string, v3 string) string {
	return v2
}

// Expression = Alternative { "|" Alternative }
func (p *pbpgParser) stateExpression() (*Expression, error) {
	var err error
	var ret *Expression
	var v1 *Alternative
	var v2temp string
	var v2 []string
	var v3temp *Alternative
	var v3 []*Alternative
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateAlternative()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2temp, err = p.literal("|")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
			if err == nil {
				v3ErrorStack := p.errorStack
				p.errorStack = &parserErrorStack{}
				v3temp, err = p.stateAlternative()
				if p.errorStack.coalesce() != nil {
					v3ErrorStack.merge(p.errorStack)
				}
				p.errorStack = v3ErrorStack
			}
			if err != nil {
				p = p.backtrack()
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionExpression(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionExpression(pos int, v1 *Alternative, v2 []string, v3 []*Alternative) *Expression {
	return &Expression{alternatives: append([]*Alternative{v1}, v3...)}
}

// Alternative = Term { Term }
func (p *pbpgParser) stateAlternative() (*Alternative, error) {
	var err error
	var ret *Alternative
	var v1 *Term
	var v2temp *Term
	var v2 []*Term
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateTerm()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2ErrorStack := p.errorStack
			p.errorStack = &parserErrorStack{}
			v2temp, err = p.stateTerm()
			if p.errorStack.coalesce() != nil {
				v2ErrorStack.merge(p.errorStack)
			}
			p.errorStack = v2ErrorStack
			if err != nil {
				p = p.backtrack()
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionAlternative(p.pos, v1, v2)
	}

	return ret, err
}

func (p *pbpgData) actionAlternative(pos int, v1 *Term, v2 []*Term) *Alternative {
	return &Alternative{terms: append([]*Term{v1}, v2...)}
}

// Term = Lex | Name | Literal | Group | Option | Repetition
func (p *pbpgParser) stateTerm() (*Term, error) {
	var err error
	var ret *Term
	var a1Pos int
	var v1 string
	var v2 string
	var v3 string
	var v4 *GOR
	var v5 *GOR
	var v6 *GOR
	a1Pos = 1
	v1ErrorStack := p.errorStack
	p.errorStack = &parserErrorStack{}
	v1, err = p.stateLex()
	if p.errorStack.coalesce() != nil {
		v1ErrorStack.merge(p.errorStack)
	}
	p.errorStack = v1ErrorStack
	if err != nil {
		a1Pos = 2
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateName()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err != nil {
			a1Pos = 3
			v3ErrorStack := p.errorStack
			p.errorStack = &parserErrorStack{}
			v3, err = p.stateLiteral()
			if p.errorStack.coalesce() != nil {
				v3ErrorStack.merge(p.errorStack)
			}
			p.errorStack = v3ErrorStack
			if err != nil {
				a1Pos = 4
				v4ErrorStack := p.errorStack
				p.errorStack = &parserErrorStack{}
				v4, err = p.stateGroup()
				if p.errorStack.coalesce() != nil {
					v4ErrorStack.merge(p.errorStack)
				}
				p.errorStack = v4ErrorStack
				if err != nil {
					a1Pos = 5
					v5ErrorStack := p.errorStack
					p.errorStack = &parserErrorStack{}
					v5, err = p.stateOption()
					if p.errorStack.coalesce() != nil {
						v5ErrorStack.merge(p.errorStack)
					}
					p.errorStack = v5ErrorStack
					if err != nil {
						a1Pos = 6
						v6ErrorStack := p.errorStack
						p.errorStack = &parserErrorStack{}
						v6, err = p.stateRepetition()
						if p.errorStack.coalesce() != nil {
							v6ErrorStack.merge(p.errorStack)
						}
						p.errorStack = v6ErrorStack
						if err != nil {
							a1Pos = -1
						}
					}
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionTerm(p.pos, a1Pos, v1, v2, v3, v4, v5, v6)
	}

	return ret, err
}

func (p *pbpgData) actionTerm(pos int, a1Pos int, v1 string, v2 string, v3 string, v4 *GOR, v5 *GOR, v6 *GOR) *Term {
	t := &Term{}
	switch a1Pos {
	case 1:
		t.lex = v1
		t.option = TERM_LEX
	case 2:
		t.name = v2
		t.option = TERM_NAME
	case 3:
		t.literal = v3
		t.option = TERM_LITERAL
	case 4:
		t.gor = v4
		t.option = TERM_GOR
	case 5:
		t.gor = v5
		t.option = TERM_GOR
	case 6:
		t.gor = v6
		t.option = TERM_GOR
	}
	return t

}

// Group = "(" Expression ")"
func (p *pbpgParser) stateGroup() (*GOR, error) {
	var err error
	var ret *GOR
	var v1 string
	var v2 *Expression
	var v3 string
	v1, err = p.literal("(")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateExpression()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			v3, err = p.literal(")")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
		}
	}
	if err == nil {
		ret = p.Data.actionGroup(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionGroup(pos int, v1 string, v2 *Expression, v3 string) *GOR {
	return &GOR{option: GOR_GROUP, expression: v2}
}

// Option = "[" Expression "]"
func (p *pbpgParser) stateOption() (*GOR, error) {
	var err error
	var ret *GOR
	var v1 string
	var v2 *Expression
	var v3 string
	v1, err = p.literal("[")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateExpression()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			v3, err = p.literal("]")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
		}
	}
	if err == nil {
		ret = p.Data.actionOption(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionOption(pos int, v1 string, v2 *Expression, v3 string) *GOR {
	return &GOR{option: GOR_OPTION, expression: v2}
}

// Repetition = "{" Expression "}"
func (p *pbpgParser) stateRepetition() (*GOR, error) {
	var err error
	var ret *GOR
	var v1 string
	var v2 *Expression
	var v3 string
	v1, err = p.literal("{")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateExpression()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			v3, err = p.literal("}")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
		}
	}
	if err == nil {
		ret = p.Data.actionRepetition(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionRepetition(pos int, v1 string, v2 *Expression, v3 string) *GOR {
	return &GOR{option: GOR_REPETITION, expression: v2}
}

// Lex = "lex" "(" functionname ")"
func (p *pbpgParser) stateLex() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	var v3 string
	var v4 string
	v1, err = p.literal("lex")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2, err = p.literal("(")
		if err != nil {
			p.errorStack.error(err, p.pos)
		}
		if err == nil {
			{
				n, lexeme, lerr := p.Data.lexfunctionname(p.input[p.pos:])
				p.pos += n
				if lerr != nil {
					err = lerr
				} else {
					err = nil
					v3 = lexeme
				}
			}
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
			if err == nil {
				v4, err = p.literal(")")
				if err != nil {
					p.errorStack.error(err, p.pos)
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionLex(p.pos, v1, v2, v3, v4)
	}

	return ret, err
}

func (p *pbpgData) actionLex(pos int, v1 string, v2 string, v3 string, v4 string) string {
	return v3
}

// Literal = """ QuotedString """
func (p *pbpgParser) stateLiteral() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	var v3 string
	v1, err = p.literal("\"")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		v2ErrorStack := p.errorStack
		p.errorStack = &parserErrorStack{}
		v2, err = p.stateQuotedString()
		if p.errorStack.coalesce() != nil {
			v2ErrorStack.merge(p.errorStack)
		}
		p.errorStack = v2ErrorStack
		if err == nil {
			v3, err = p.literal("\"")
			if err != nil {
				p.errorStack.error(err, p.pos)
			}
		}
	}
	if err == nil {
		ret = p.Data.actionLiteral(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionLiteral(pos int, v1 string, v2 string, v3 string) string {
	return v2
}

// Name = name
func (p *pbpgParser) stateName() (string, error) {
	var err error
	var ret string
	var v1 string
	{
		n, lexeme, lerr := p.Data.lexname(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = lerr
		} else {
			err = nil
			v1 = lexeme
		}
	}
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		ret = p.Data.actionName(p.pos, v1)
	}

	return ret, err
}

func (p *pbpgData) actionName(pos int, v1 string) string {
	return v1
}

//	Lexer directives.
//
// Code = code
func (p *pbpgParser) stateCode() (string, error) {
	var err error
	var ret string
	var v1 string
	{
		n, lexeme, lerr := p.Data.lexcode(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = lerr
		} else {
			err = nil
			v1 = lexeme
		}
	}
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		ret = p.Data.actionCode(p.pos, v1)
	}

	return ret, err
}

func (p *pbpgData) actionCode(pos int, v1 string) string {
	return v1
}

// QuotedString = quotedstring
func (p *pbpgParser) stateQuotedString() (string, error) {
	var err error
	var ret string
	var v1 string
	{
		n, lexeme, lerr := p.Data.lexquotedstring(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = lerr
		} else {
			err = nil
			v1 = lexeme
		}
	}
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		ret = p.Data.actionQuotedString(p.pos, v1)
	}

	return ret, err
}

func (p *pbpgData) actionQuotedString(pos int, v1 string) string {
	return v1
}

// Comment = "#" comment
func (p *pbpgParser) stateComment() error {
	var err error
	var v1 string
	var v2 string
	v1, err = p.literal("#")
	if err != nil {
		p.errorStack.error(err, p.pos)
	}
	if err == nil {
		{
			n, lexeme, lerr := p.Data.lexcomment(p.input[p.pos:])
			p.pos += n
			if lerr != nil {
				err = lerr
			} else {
				err = nil
				v2 = lexeme
			}
		}
		if err != nil {
			p.errorStack.error(err, p.pos)
		}
	}
	if err == nil {
		p.Data.actionComment(p.pos, v1, v2)
	}

	return err
}

func (p *pbpgData) actionComment(pos int, v1 string, v2 string) {
	p.out.WriteString("// " + v2 + "\n")
}

func Parsepbpg(input string, data *pbpgData) error {
	p := newpbpgParser(input, data)

	err := p.stateProgram()
	if err == nil {
		if strings.TrimSpace(p.input[p.pos:]) != "" {
			err = p.errorStack.coalesce()
			return err
		}
	} else {
		err = p.errorStack.coalesce()
	}

	return err
}

type pbpgParser struct {
	input       string
	pos         int
	lineOffsets []int
	Data        *pbpgData
	errorStack  *parserErrorStack

	predictStack []*pbpgParser
}

func newpbpgParser(input string, data *pbpgData) *pbpgParser {
	return &pbpgParser{
		input:       input,
		lineOffsets: pbpgGenerateLineOffsets(input),
		Data:        data,
		errorStack:  &parserErrorStack{},
	}
}

func pbpgGenerateLineOffsets(input string) []int {
	var ret []int

	lines := strings.Split(input, "\n")

	offset := 0
	for _, v := range lines {
		ret = append(ret, len(v)+1+offset)
		offset += len(v) + 1
	}
	return ret
}

func (p *pbpgParser) literal(want string) (string, error) {
	var errExpected = fmt.Errorf("expected %v", want)

	count := 0
	for r, s := utf8.DecodeRuneInString(p.input[p.pos+count:]); s > 0 && unicode.IsSpace(r); r, s = utf8.DecodeRuneInString(p.input[p.pos+count:]) {
		count += s
	}

	if strings.HasPrefix(p.input[p.pos+count:], want) {
		p.pos += count + len(want)
		return want, nil
	}

	return "", errExpected
}

func (p *pbpgParser) predict() *pbpgParser {
	p.predictStack = append(p.predictStack, p)
	return &pbpgParser{
		input:        p.input,
		pos:          p.pos,
		lineOffsets:  p.lineOffsets,
		predictStack: p.predictStack,
		errorStack:   p.errorStack,
		Data:         p.Data,
	}
}

func (p *pbpgParser) backtrack() *pbpgParser {
	pp := p.predictStack[len(p.predictStack)-1]
	pp.predictStack = pp.predictStack[:len(pp.predictStack)-1]
	pp.errorStack = p.errorStack
	return pp
}

func (p *pbpgParser) accept() *pbpgParser {
	pp := p.backtrack()
	pp.pos = p.pos
	return pp
}

type parserErrorStack struct {
	stack []*parseError
}

type parseError struct {
	err error
	pos int
}

func (e *parserErrorStack) clear() {
	e.stack = []*parseError{}
}

func (e *parserErrorStack) merge(e2 *parserErrorStack) {
	e.stack = append(e.stack, e2.stack...)
}

func (e *parserErrorStack) error(err error, pos int) {
	e.stack = append(e.stack, &parseError{err: err, pos: pos})
}

func (e *parserErrorStack) coalesce() error {
	var bestDepth int
	var es []error

COALESCE_OUTER:
	for _, v := range e.stack {
		if v.pos > bestDepth {
			bestDepth = v.pos
			es = []error{v.err}
		} else if v.pos == bestDepth {
			// deduplicate errors at a given depth
			for _, w := range es {
				if w.Error() == v.err.Error() {
					continue COALESCE_OUTER
				}
			}
			es = append(es, v.err)
		}
	}

	if len(es) == 0 {
		return nil
	} else if len(es) == 1 {
		return es[0]
	} else {
		// print the error stack in reverse order
		var ret string
		for i := len(es) - 1; i >= 0; i-- {
			ret += es[i].Error() + "\n"
		}
		return errors.New(strings.TrimSpace(ret))
	}
}

func (e *parserErrorStack) depth() int {
	var ret int
	for _, v := range e.stack {
		if v.pos > ret {
			ret = v.pos
		}
	}
	return ret
}
